import numpy as npimport networkx as nximport jsonimport randomjson_file = 'keyboard-layout_1.json'ken_array = np.emptywith open(json_file, encoding="utf8") as f:    json_dict = json.load(f)    adjy = 0    skipy = 0    ken_list = []    for i in json_dict:        width = 0        skipx = 0        for j in i:            if isinstance(j, str):                x = skipx+(width/2)                y = float(adjy + skipy)                ken_list.append([x, y])            elif isinstance(j, dict):                for key in j:                    if key == 'x':                        # print("add ", j['x'], " horizontal space")                        skipx += float(j['x'])                    elif key == 'y':                        # print("add ", j['y'], " vertical space")                        skipy += float(j['y'])                    elif key == 'w':                        # print("add key width by ", j['w'])                        width = float(j['w']) - 1                    elif key == 'h':                        "add key height(downwards) by , j['h'])"                        # adjy += float(j['h']) / 2                    elif key == 'x2' or key == 'y2' or key == 'w2' or key == 'h2':                        "uh oh"                    elif key == 'a' or key == 'f' or key == 'f2' or key == 'p' or key == 's':                        "something about font"            if width != 0:                skipx += width            skipx += 1            width = 0        skipy += 1    #puts every kex and key into a numpy array where each index represents a key.    ken_array = np.array(list(ken_list)) #starts at 0 but starts at 1 in mankey.#looks up the smallest matrix available, if matrix is square then columns and row will match, otherwise add extra columnken_size = len(ken_array)man_size = 0 #value given aftermax = 0may = 0if np.sqrt(ken_size) == int(np.sqrt(ken_size)):    max = np.sqrt(ken_size)    may = maxelse:    max = int(np.sqrt(ken_size)) + 1    may = int(np.sqrt(ken_size))man_size = max * may#creates man_array which is the matrix, use this to create all lines that will be checked for keybord fitness.man_array = np.emptyrows = []k = 0for i in range(may):    onerow = []    onerow.clear()    for j in range(0,max):        onerow.append(k)        k += 1    rows.append(onerow)man_array = np.array(list(rows))print(man_array)#mlines lists of every electral line(rows and columns) in the matrix.mlines = []for mrow in rows:    mlines.append(mrow)lrows = np.array(list(mlines))mlines.clear()for x in range(0, max):    mcol = []    for y in rows:        mcol.append(y[x])    mlines.append(mcol)lcols = np.array(list(mlines))#should i create a class for the individual in population?#the class would include the list of ken2man and fitness.#ken2man or man2ken?#we need man2ken to be able to calculate the length/fitness#we need ken2man to be able know which man exist in keyboard.    #why cant we just have a list of the existing man and then use each index as the ken?    #we look up which index the man have and take all the index to calculate kex and key?class Keyboard:    def __init__(self):        self.fitness = 0        self.fitness_New = 0        self.ken = np.random.choice(man_size, size=ken_size, replace=False) #creates a one dimensinal numpy array        self.mankey = np.zeros((may, max, 2)) #3d array with nodes, keys, and usage status.        for idx, node in np.ndenumerate(man_array):            self.mankey[idx[0]][idx[1]][0] = node        for idx, key in np.ndenumerate(self.ken): #idx(index) gives tuples for the array indices, key is the item in the array.            # print(f"this is the index: {idx}, {type(idx)}, this is the key {key}")            man_indices = np.argwhere(man_array == key).flatten()            self.mankey[man_indices[0]][man_indices[1]][1] = idx[0]+1        #print(f"ndarray with keys, nodes {self.mankey}, it has the shape {np.shape(self.mankey)}, {type(np.shape(self.mankey))}")    def fitness_Score_new(self):        #grab the columns and lines if they are used by checking [:,:,2]        # for idx, ken in np.ndenumerate(self.mankey[:, :, 1]):        #     if self.mankey[idx[0], idx[1], 2]:        #         print(ken_array[int(ken)][:])        calcs = 0        line = []        col_Fitness = 0        row_Fitness = 0        for x in range(0, max):            for y in range(0, may): #this loop goes through the column in the matrix                if self.mankey[y, x, 1] != 0: #this checks if the matrix node is being used in the keyboard.                    idx = int(self.mankey[y, x, 1]) #grabs the keyboard switch number. Ken                    # print(f" this is row: {y} and column: {x}, {self.mankey[y,x,1]}, this is ken_array: {ken_array[idx]}")                    line.append(ken_array[idx-1]) #grabs keyboard switch coord using the Ken                    a = np.stack(line, axis=0) #stacks all of the switch coordinates and later sorts them and defines the array as "col_Wire"            line.clear()            col_Wire = a[a[:, 0].argsort()] #this is the sorted column wire.            # print(f"cols: \n{col_Wire}")            for idx, coord in np.ndenumerate(col_Wire):                if len(col_Wire)-1 != idx[0] and idx[1] == 0: #coord goes through all values, both horizontal and vertical position, idx[1] is always 0 when its horizontal position.                    #print(f"this is coord {coord} and this is {idx} is that equal to {col_Wire[idx]}")                    idxx = idx[0] #idx contains both indices, first is the key and the second index 0 is horizontal position and 1 is vertical position.                    x_Fitness = col_Wire[idxx+1, 0] - coord #grabs coord and x coord in col_Wire to measure horizontal distance                    y_Fitness = np.abs(col_Wire[idxx+1, 1] - col_Wire[idxx, 1]) #grabs vertical coordinates and measures vertical distance                    col_Fitness += x_Fitness                    col_Fitness += y_Fitness                    # print(f"adding vertical wires: {x_Fitness+y_Fitness}")                    #print(f"this is x score: {x_Fitness} and this is y score: {y_Fitness}")                elif len(col_Wire)-1 == idx[0]:                    #print(len(col_Wire)-1, idx[0])                    break                    #print(f"this is x,y: {x, y}")            calcs += 1        for y in range(0, may):            for x in range(0, max):                if self.mankey[y, x, 1] != 0:                    idx = int(self.mankey[y, x, 1])                    line.append(ken_array[idx-1])                    a = np.stack(line, axis=0)            line.clear()            row_Wire = a[a[:, 0].argsort()]            # print(f"rows: \n{row_Wire}")            for idx, coord in np.ndenumerate(row_Wire):                if len(row_Wire) - 1 != idx[0] and idx[1] == 0:                    idxx = idx[0]                    x_Fitness = row_Wire[idxx + 1, 0] - coord                    y_Fitness = np.abs(row_Wire[idxx + 1, 1] - row_Wire[idxx, 1])                    row_Fitness += x_Fitness                    row_Fitness += y_Fitness                    # print(f"adding horizontal wires: {y_Fitness+x_Fitness}")                elif len(row_Wire) - 1 == idx[0]:                    break            #print(col_Wire, np.shape(col_Wire))            calcs += 1        print(f"this is the new fitness score {col_Fitness+row_Fitness}, calculations {calcs}")    def fitness_Score(self): #This one doesnt know if any of the nodes are not used, therefore it counts the distance to that node and then from that node to the next, these two additional distances are incorrect.        #Take all columns and rows and look for them in the man. DONE mlines is a list with all rows and columns        #Sort by X and calculate distance for each column and row and summarize score        #print("not done")        #We have two arrays, lrows and lcols, these two contain        calcs = 0        node_Line = np.zeros((len(lrows[0]), 2))        fit_Tot = 0        for r in lrows:            index = 0            for node in r:                #print(node, np.argwhere(self.ken == node), ken_array[np.argwhere(self.ken == node)])                np.put(node_Line, [index, index+1], ken_array[np.argwhere(self.ken == node)-1])                index += 2                #print(node_Line)            node_Line = node_Line[node_Line[:, 0].argsort()] #sorts the line according to geometrical x position.            # print(f"this is node_Line {index}: \n{node_Line}")            #print("this is len", len(node_Line))            fit_Value = 0 #we add fitness value between each node in an electrical wire with the for-loop below            for i in range(len(node_Line)-1): #we compare two elements and therefore skip one.                fit_Value += node_Line[i+1][0]-node_Line[i][0] + abs(node_Line[i+1][1]-node_Line[i][1])                # print(f"old. adding horizontal wires: {node_Line[i+1][0]-node_Line[i][0] + abs(node_Line[i+1][1]-node_Line[i][1])}")                # if node_Line[i][0] == 0:                #     print(node_Line[i])            fit_Tot += fit_Value            calcs += 1        node_Line = np.zeros((len(lcols[0]), 2))        for c in lcols:            index = 0            for node in c:                np.put(node_Line, [index, index + 1], ken_array[np.argwhere(self.ken == node)-1])                index += 2            node_Line = node_Line[node_Line[:, 0].argsort()]  # sorts the line according to geometrical x position.            # print(f"this is node_Line {index}: \n{node_Line}")            fit_Value = 0  # we add fitness value between each node in an electrical wire with the for-loop below            for i in range(len(node_Line) - 1):  # we compare two elements and therefore skip one.                fit_Value += node_Line[i + 1][0] - node_Line[i][0] + abs(node_Line[i + 1][1] - node_Line[i][1])                # print(f"old. adding vertical wires: {node_Line[i + 1][0] - node_Line[i][0] + abs(node_Line[i + 1][1] - node_Line[i][1])}")                # if node_Line[i][0] == 0:                #     print(node_Line[i])            fit_Tot += fit_Value            calcs += 1        self.fitness = fit_Tot        #print(self.fitness, calcs)        #The above calculation, does it line by line. This next calculation will create a 3d array where one plane contains the matrix nodes and below it are the keyboard coordinates and a true/false if used.        #print(man_array, "\nman_array with shape", np.shape(man_array))        #print(self.ken, "\nself.ken with shape", np.shape(self.ken))        #print(ken_array, "\nken_array with shape", np.shape(ken_array))        #look up value in self.ken, use that value as index in ken_array and add those ken_array values into man_array #class Population:    def __init__(self, count):        # initialize keyboard population        self.count = count        self.population = [Keyboard() for _ in range(self.count)]    def node_change(self, okey, nkey, key, row, col):        key_Idx = np.argwhere(okey[:, :, 1] == key[1]).flatten()        # print(f"we're changing row:{row}, key:{key}, we're moving {key[1]} to {row,key[0]} and placing {keea_Mankey[row, i, 1]} on {key_Idx}")        nkey[key_Idx[0], key_Idx[1], 1] = okey[row, col, 1] #this moves the old key to the index of the new keys current old index effectively step 1 of swapping the old key and new key positions        nkey[row, col, 1] = key[1] #this replaces the old key with the new key. effectively step 2 in swapping their positions.    def copulate(self, Keea, Keeb):        chosen_Wires = np.random.choice(max+may, size=np.random.randint(0, max+may, dtype=int), replace=False)        #print(f"this is random number: {chosen_Wires}, shape: {np.shape(chosen_Wires)}")        #print(f"this is man_array, \n{man_array}")        keea_Mankey = np.copy(Keea.mankey)        keeb_Mankey = np.copy(Keeb.mankey)        new_Keea = np.copy(Keea.mankey)        new_Keeb = np.copy(Keeb.mankey)        print(f"this is keea_mankey[:, :, 1]: \n{keea_Mankey[: , :, 1]}")        print(f"this is keeb_mankey[:, :, 1]: \n{keeb_Mankey[: , :, 1]}")        for wire in chosen_Wires:            if wire >= max: #this is true of the wire number is representing a row.                #wire is a number between, 0 and max+may = 11+10 = 21, from 0 to max are columns.                row = wire-max                #print(f"this wire is a row, {wire}")                keea_Row = Keea.mankey[row, :, :] #this is the row that will be swapped to keeb from keea                keeb_Row = Keeb.mankey[row, :, :]                print(f"this is keea_Row: \n{keea_Row}, \nthis is keeb_Row: \n{keeb_Row}")                for i, key in enumerate(keeb_Row): #key[0] = node, key[1] = key                    if key[1] != 0:                        self.node_change(keea_Mankey, new_Keea, key, row, i)                for j, keyb in enumerate(keea_Row):                    if keyb[1] != 0:                        self.node_change(keeb_Mankey, new_Keeb, keyb, row, j)                #print(f"this is keea_Row and keeb_Row: \n{keea_Row} \n{keeb_Row}")            else: #everything else between 0 and max-1 is a column.                col = wire                keea_Col = Keea.mankey[:, col, :]                keeb_Col = Keeb.mankey[:, col, :]                #print(f"this is keea_Col: \n{keea_Col}, \nthis is keeb_Col: \n{keeb_Col}")                for i, key in enumerate(keeb_Col): #key[0] = node, key[1] = key                    if key[1] != 0:                        key_Idx = np.argwhere(keea_Mankey[:, :, 1] == key[1]).flatten()                        new_Keea[key_Idx[0], key_Idx[1], 1] = keea_Mankey[i, col, 1]                        new_Keea[i, col, 1] = key[1]                for i, key in enumerate(keea_Col): #key[0] = node, key[1] = key                    if key[1] != 0:                        key_Idx = np.argwhere(keeb_Mankey[:, :, 1] == key[1]).flatten()                        new_Keeb[key_Idx[0], key_Idx[1], 1] = keeb_Mankey[i, col, 1]                        new_Keeb[i, col, 1] = key[1]            print(f"this is new keea, \n{new_Keea[:, :, 1]}")            print(f"this is new keeb, \n{new_Keeb[:, :, 1]}")def test_Func():    print("func")def test():    first_array = np.linspace((0,10),(19,200),num=20, dtype=int)    print(first_array)    where = np.where(first_array == 10) #gives a tuple    flatnonzero =np.flatnonzero(first_array == 10) #wtf is this. answer, it orders them into 1d array and takes the index...    argwhere = np.argwhere(first_array == 10) #this gives correct indices    print(f" this is where: {where}\n this if flatnonzero: {flatnonzero}\n this is argwhere: {argwhere}")def simulate_rolls():    array_2d = [[0] * 11 for _ in range(10)]    rolls = 0    rows_affected = set()    cols_affected = set()    rolled_values = set()    while len(rows_affected) < 10 or len(cols_affected) < 11:        value = random.randint(1, 110)        if value not in rolled_values:            rolled_values.add(value)            row = (value - 1) // 11            col = (value - 1) % 11            if array_2d[row][col] == 0:                array_2d[row][col] = 1                rolls += 1                rows_affected.add(row)                cols_affected.add(col)    return rollsdef chat_GPT():    num_iterations = 1000  # Number of iterations to run the simulation    total_rolls = 0    for _ in range(num_iterations):        total_rolls += simulate_rolls()    average_rolls = total_rolls / num_iterations    print(f"Average number of rolls over {num_iterations} runs: {average_rolls}")def test_Print():    a = Keyboard()    #print("this is man in the class Keyboard\n", a.ken)    pop = Population(10)    pop.copulate(pop.population[0], pop.population[1])    #print(ken_array)    #print(man_array)    #print(lrows, lrows.shape)    #print(lcols, lcols.shape)    #a.fitness_Score()    a.fitness_Score_new()test_Print()#test_Func()